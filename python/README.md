# バックエンド(Python)
画像認識や表情推定の機能を提供するバックエンドです．

## 実行方法
以下のコマンドでバックエンドを起動します．
仮想環境を起動していること前提です．
```bash
pip install --no-cache-dir -r requirements.txt
python3 app.py
```
他のフロントエンドやGoAPIやインフラと共に実行する場合は以下のコマンドを実行してください．
```bash
docker compose up
```
docker composeの初回実行時は以下のコマンドを実行してください．
```bash
docker compose up --build
```
## ディレクトリ構成
```
.
├── Dockerfile
├── README.md
├── main.py
└── requirements.txt // Pythonバックエンドの依存関係
```
## requirements.txt
Pythonバックエンドの依存関係が記述されています．何かライブラリを追加した場合はこのファイルにライブラリを記載してください．

## app.py
バックエンドのエントリーポイントです．APIのルーティングを記述しています．また，Flaskでサーバーを立ち上げている．OpenCVで顔認識をして，DeepFaceで表情推定をしている．

1. **初期設定**  
   ログや S3 クライアント,テンプレート画像の読み込み,並びに赤色輪郭の抽出など,事前の初期化処理を行う．  
   これにより,後続の画像解析およびロゴ検出処理で必要な情報が準備される．

2. **エンドポイント `/analyze`**  
   フロントエンドや他のクライアントから送信された画像データに対して顔検出と感情解析を行い,その結果を返す．  
   DeepFace による詳細な感情解析と,複数顔がある場合のスコア平均化処理を行う点が特徴である．

3. **エンドポイント `/detect`**  
   画像データに対して,テンプレートマッチングと赤色領域の形状比較を組み合わせ,ロゴの検出を行う．  
   マッチング手法の組み合わせにより,信頼性の高いロゴ検出を試みる実装となっている．

---

### 1. ログ設定とライブラリのインポート

- **ログ設定**  
  `logging.basicConfig(level=logging.DEBUG)` により,DEBUG レベルのログを有効化している．  
  また,`boto3.set_stream_logger('botocore', level=logging.DEBUG)` を呼び出し,Boto3（AWS SDK）の内部ログも DEBUG レベルで出力するように設定している．  
  これにより,アプリケーションや AWS 関連の詳細なログ情報を確認することができる．

- **ライブラリのインポート**  
  必要なライブラリとして,Flask,os,boto3（AWS S3 用）,OpenCV (cv2),DeepFace,numpy,base64 をインポートしている．  
  これらのライブラリによって,画像処理,感情解析,S3 操作の処理を実現している．

---

### 2. S3 クライアントの作成

- **環境変数からの設定取得**  
  `S3_ENDPOINT_URL`,`AWS_REGION`,`AWS_ACCESS_KEY_ID`,`AWS_SECRET_ACCESS_KEY` を環境変数から取得し,デフォルト値（例: `http://localstack:4566` や `test`）を設定している．

- **S3 クライアントの初期化**  
  `boto3.client` を用いて S3 クライアントを生成している．  
  `endpoint_url` や `region_name` などのパラメーターを指定し,ローカル環境（LocalStack 等）でのテスト用に設定されている可能性がある．

---

### 3. 赤い部分の輪郭検出関数: `get_red_contours`

- **目的**  
  BGR 形式の画像から,赤色領域の輪郭を抽出するための関数である．

- **処理内容**
    1. 画像を HSV 色空間に変換する．
    2. 赤色の範囲を2種類設定（低い赤と高い赤）し,`cv2.inRange` を使ってマスクを作成する．
    3. 2つのマスクを論理和（`bitwise_or`）で統合する．
    4. ノイズ除去のため,モルフォロジー処理（オープニングとクロージング）を適用する．
    5. `cv2.findContours` で輪郭を抽出し,面積が 50 未満の輪郭をフィルタリングして返す．

---

### 4. テンプレート画像の読み込みと前処理

- **テンプレート画像の取得**  
  テンプレート画像 `logo.png` をグレースケール（`cv2.IMREAD_GRAYSCALE`）とカラー（`cv2.IMREAD_COLOR`）の両方で読み込む．  
  読み込みに失敗した場合は,ログにエラーを出力してプロセスを終了する．

- **赤い部分の抽出**  
  カラー画像から `get_red_contours` 関数を用いて赤い部分の輪郭を抽出し,グローバル変数 `template_red_contours` に保持する．  
  これにより,後続のロゴ検出処理（形状の類似度評価）で使用される．

- **閾値の設定**
    - テンプレートマッチングの閾値 `tm_threshold` は 0.45 に設定されており,  
      マッチング結果の最大値がこの閾値を超えた場合に,ロゴの候補とみなす．
    - 赤色領域の形状類似度の閾値 `red_threshold` は 0.8 に設定され,  
      この値に基づいて最終的なロゴ検出判断を行う．

---

### 5. エンドポイント `/analyze` の説明
顔検出および感情解析を行い,解析結果を JSON 形式で返すエンドポイントである．

#### 処理の流れ

1. **リクエストのパース**
    - JSON ボディから `file_name`,`content_type`,`image_data` を取得する．
    - いずれかが存在しなければ,400 番（Bad Request）を返却する．

2. **画像データのデコードと読み込み**
    - Base64 エンコードされた `image_data` をデコードする．
    - データ URI スキームのようなプレフィックスが付与されている場合は,それを取り除く．
    - バイト列から NumPy 配列を生成し,`cv2.imdecode` を用いて画像を読み込む．
    - 画像の読み込みに失敗した場合は,500 番（Internal Server Error）を返す．

3. **顔検出**
    - 画像をグレースケールに変換し,OpenCV の Haar Cascade（`haarcascade_frontalface_default.xml`）を用いて顔検出を行う．
    - 顔検出の結果が空の場合はエラーを返す．
    - `cv2.groupRectangles` により重複する検出領域を統合する．

4. **DeepFace を用いた感情解析**
    - 検出された各顔領域ごとに ROI（関心領域）を抽出し,`DeepFace.analyze` を使用して感情解析を実施する．
    - 解析結果がネスト可能な場合があるため,再帰的に結果を平坦化する補助関数 `flatten_deepface_result` を定義している．
    - 各結果から `emotion` 情報と `dominant_emotion` を抽出し,リスト `results` に追加する．

5. **解析結果の集約**
    - 複数の顔が検出された場合,各感情のスコアの平均値を計算し,  
      平均値が最も高い感情を最終的な `dominant_emotion` として決定する．
    - 集約した結果を JSON 形式で返却する（HTTP 200）．

6. **エラーハンドリング**
    - 顔検出や DeepFace の解析処理で例外が発生した場合は,エラー内容をログに記録し,  
      適切なエラーレスポンス（HTTP 500）を返す．

---

### 6. エンドポイント `/detect` 
与えられた画像からロゴの検出を行うエンドポイントである．

#### 処理の流れ

1. **リクエストのパース**
    - リクエストの JSON ボディから `image` キーを取得する．
    - キーが存在しなければ 400 番（Bad Request）のエラーを返す．

2. **画像のデコードと読み込み**
    - Base64 エンコードされた `image` データをデコードし,NumPy 配列へ変換する．
    - `cv2.imdecode` を用いて画像を読み込む．
    - 読み込みに失敗した場合はエラーを返す．

3. **テンプレートマッチングによるロゴ検出**
    - 入力画像をグレースケールに変換し,`cv2.matchTemplate` を用いてテンプレート画像（グレースケール版）との相関を計算する．
    - 得られた最大相関値（`raw_max_val`）が,設定した閾値（`tm_threshold`）を上回れば,ロゴ候補として評価を行う．

4. **赤色領域の形状評価**
    - テンプレート画像と入力画像の赤色領域の輪郭を,それぞれ `get_red_contours` 関数で抽出する．
    - 輪郭同士を `cv2.matchShapes` により比較し,その最小のマッチングスコアから類似度スコア（`red_shape_similarity`）を算出する．
    - この類似度が `red_threshold` を上回れば,ロゴが検出されたと判断する．
    - テンプレートマッチングの結果が閾値に満たない場合は,ロゴ検出自体が行われない．

5. **レスポンスの返却**
    - 最終的に,検出結果（`logo_detected` というブール値）を JSON 形式で返却する（HTTP 200）．

---

### 7. サーバーの起動

- **実行ブロック**  
  最後に,`if __name__ == '__main__':` ブロックで,環境変数 `PORT` からポート番号を取得（デフォルトは 8000）し,  
  `app.run(host='0.0.0.0', port=port)` によって Flask サーバーを起動する．

